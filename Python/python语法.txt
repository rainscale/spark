Python 保留字符
下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。
所有Python的关键字只包含小写字母。
and			exec		not
assert		finally		or
break		for			pass
class		from		print
continue	global		raise
def			if			return
del			import		try
elif		in			while
else		is			with
except		lambda		yield
打印keyword：
import keyword
print(keyword.kwlist)
'''
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 
'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 
'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
'''

Python运算符优先级
以下表格列出了从最高到最低优先级的所有运算符：
运算符						描述
**							指数 (最高优先级)
~ + -						按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
* / % //					乘，除，取模和取整除
+ -							加法减法
>> <<						右移，左移运算符
&							位 'AND'
^ |							位运算符
<= < > >=					比较运算符
<> == !=					等于运算符
= %= /= //= -= += *= **=	赋值运算符
is is not					身份运算符
in not in					成员运算符
not and or					逻辑运算符

标准数据类型
Python3中常见的数据类型有：
Number（数字）
String（字符串）
bool（布尔类型）
List（列表）
Tuple（元组）
Set（集合）
Dictionary（字典）
Python3 的六个标准数据类型中：
不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。

Number（数字）
Python3支持int、float、bool、complex（复数）。
在Python3里，只有一种整数类型int，表示为长整型，没有python2中的Long。
内置的type()函数可以用来查询变量所指的对象类型。
a=20
b=5.5
c=True
d=4+3j
print(type(a), type(b), type(c), type(d)) # <class 'int'> <class 'float'> <class 'bool'> <class 'complex'>
此外还可以用isinstance来判断：
a = 111
print(isinstance(a, int)) # True
isinstance 和type的区别在于：
type()不会认为子类是一种父类类型。
isinstance()会认为子类是一种父类类型。
注意：Python3中，bool是int的子类，True和False可以和数字相加， True==1、False==0会返回True，但可以通过is来判断类型。
在Python2中是没有布尔型的，它用数字0表示False，用1表示True。
注意: 在Python中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为True，
只有 0、空字符串、空列表、空元组等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。

List（列表）
List（列表）是Python中使用最频繁的数据类型。
列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。
列表是写在方括号[]之间、用逗号分隔开的元素列表。
和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。
列表截取的语法格式如下：
变量[头下标:尾下标]
索引值以0为开始值，-1为从末尾的开始位置。
加号+是列表连接运算符，星号*是重复操作。
与Python字符串不一样的是，列表中的元素是可以改变的
List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。
注意：
1、列表写在方括号之间，元素用逗号隔开。
2、和字符串一样，列表可以被索引和切片。
3、列表可以使用+操作符进行拼接。
4、列表中的元素是可以改变的。
Python列表截取可以接收第三个参数，参数作用是截取的步长，如果第三个参数为负数表示逆向读取。

Tuple（元组）
元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。
元组中的元素类型也可以不相同
元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。
其实，可以把字符串看作一种特殊的元组。
虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。
构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：
tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
如果你想创建只有一个元素的元组，需要注意在元素后面添加一个逗号，以区分它是一个元组而不是一个普通的值，
这是因为在没有逗号的情况下，Python会将括号解释为数学运算中的括号，而不是元组的表示。
如果不添加逗号，如下所示，它将被解释为一个普通的值而不是元组：
not_a_tuple = (42)
这样的话，not_a_tuple 将是整数类型而不是元组类型。
string、list 和 tuple 都属于 sequence（序列）。
注意：
1、与字符串一样，元组的元素不能修改。
2、元组也可以被索引和切片，方法一样。
3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。
4、元组也可以使用 + 操作符进行拼接。

Set（集合）
Python 中的集合（Set）是一种无序、可变的数据类型，用于存储唯一的元素。
集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。
在 Python 中，集合使用大括号 {} 表示，元素之间用逗号,分隔。
另外，也可以使用 set() 函数创建集合。
注意：创建一个空集合必须用 set() 而不是{}，因为{}是用来创建一个空字典。
创建格式：
parame = {value01,value02,...}
或者
set(value)

Dictionary（字典）
字典（dictionary）是Python中另一个非常有用的内置数据类型。
列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。
字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。
键(key)必须使用不可变类型。
在同一个字典中，键(key)必须是唯一的。
构造函数 dict() 可以直接从键值对序列中构建字典。
{x: x**2 for x in (2, 4, 6)} 该代码使用的是字典推导式，更多推导式内容可以参考：Python推导式。
另外，字典类型也有一些内置的函数，例如 clear()、keys()、values()等。
注意：
1、字典是一种映射类型，它的元素是键值对。
2、字典的关键字必须为不可变类型，且不能重复。
3、创建空字典使用{}。

bytes类型
在 Python3 中，bytes 类型表示的是不可变的二进制序列（byte sequence）。
与字符串类型不同的是，bytes 类型中的元素是整数值（0 到 255 之间的整数），而不是Unicode字符。
bytes类型通常用于处理二进制数据，比如图像文件、音频文件、视频文件等等。在网络编程中，也经常使用bytes类型来传输二进制数据。
创建bytes对象的方式有多种，最常见的方式是使用 b 前缀：
此外，也可以使用bytes()函数将其他类型的对象转换为bytes类型。bytes()函数的第一个参数是要转换的对象，
第二个参数是编码方式，如果省略第二个参数，则默认使用UTF-8编码：
x = bytes("hello", encoding="utf-8")
与字符串类型类似，bytes 类型也支持许多操作和方法，如切片、拼接、查找、替换等等。
同时，由于bytes类型是不可变的，因此在进行修改操作时需要创建一个新的 bytes 对象。例如：
x = b"hello"
y = x[1:3]  # 切片操作，得到 b"el"
z = x + b"world"  # 拼接操作，得到 b"helloworld"
需要注意的是，bytes类型中的元素是整数值，因此在进行比较操作时需要使用相应的整数值。例如：
x = b"hello"
if x[0] == ord("h"):
    print("The first element is 'h'")
其中ord()函数用于将字符转换为相应的整数值。

Python数据类型转换
以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。
函数						描述
int(x [,base])				将x转换为一个整数
float(x)					将x转换到一个浮点数
complex(real [,imag])		创建一个复数
str(x)						将对象 x 转换为字符串
repr(x)						将对象 x 转换为表达式字符串
eval(str)					用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s)					将序列 s 转换为一个元组
list(s)						将序列 s 转换为一个列表
set(s)						转换为可变集合
dict(d)						创建一个字典。d 必须是一个 (key, value)元组序列。
frozenset(s)				转换为不可变集合
chr(x)						将一个整数转换为一个字符
ord(x)						将一个字符转换为它的整数值
hex(x)						将一个整数转换为一个十六进制字符串
oct(x)						将一个整数转换为一个八进制字符串

Python算术运算符
运算符		描述
+			加 - 两个对象相加
-			减 - 得到负数或是一个数减去另一个数
*			乘 - 两个数相乘或是返回一个被重复若干次的字符串
/			除 - x除以y
%			取模 - 返回除法的余数
**			幂 - 返回x的y次幂
//			取整除 - 往小的方向取整数
>>> 9//2
4
>>> -9//2
-5

Python比较运算符
所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。
以下假设变量a为10，变量b为20：
运算符		描述								实例
==			等于 - 比较对象是否相等				(a == b) 返回False。
!=			不等于 - 比较两个对象是否不相等		(a != b) 返回True。
>			大于 - 返回x是否大于y				(a > b) 返回False。
<			小于 - 返回x是否小于y。				(a < b) 返回True。
>=			大于等于 - 返回x是否大于等于y。		(a >= b) 返回False。
<=			小于等于 - 返回x是否小于等于y。		(a <= b) 返回True。

Python赋值运算符
以下假设变量a为10，变量b为20：
运算符		描述					实例
=			简单的赋值运算符		c = a + b 将 a + b 的运算结果赋值为 c
+=			加法赋值运算符			c += a 等效于 c = c + a
-=			减法赋值运算符			c -= a 等效于 c = c - a
*=			乘法赋值运算符			c *= a 等效于 c = c * a
/=			除法赋值运算符			c /= a 等效于 c = c / a
%=			取模赋值运算符			c %= a 等效于 c = c % a
**=			幂赋值运算符			c **= a 等效于 c = c ** a
//=			取整除赋值运算符		c //= a 等效于 c = c // a
:=			海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。Python3.8 版本新增运算符。
在这个示例中，赋值表达式可以避免调用 len() 两次:
if (n := len(a)) > 10:
    print(f"List is too long ({n} elements, expected <= 10)")
在 Python 3.8 及更高版本中，引入了一种新的语法特性，称为"海象运算符"（Walrus Operator），它使用 := 符号。
这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。
使用海象运算符可以在一些情况下简化代码，尤其是在需要在表达式中使用赋值结果的情况下。
这对于简化循环条件或表达式中的重复计算很有用。
# 传统写法
n = 10
if n > 5:
    print(n)
# 使用海象运算符
if (n := 10) > 5:
    print(n)

Python位运算符
按位运算符是把数字看作二进制来进行计算的。
下表中变量a为60，b为13二进制格式如下：
a = 0011 1100
b = 0000 1101
-----------------
a&b = 0000 1100
a|b = 0011 1101
a^b = 0011 0001
~a  = 1100 0011
运算符		描述
&			按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
|			按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1
^			按位异或运算符：当两对应的二进位相异时，结果为1
~			按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于-x-1
<<			左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0
>>			右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数

Python逻辑运算符
Python语言支持逻辑运算符。
运算符		逻辑表达式		描述
and			x and y			布尔"与" - 如果x为False，x and y返回x的值，否则返回y的计算值。
or			x or y			布尔"或" - 如果x是True，它返回x的值，否则它返回y的计算值。
not			not x			布尔"非" - 如果x为True，返回False。如果x为False，它返回True。

Python成员运算符
除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。
运算符		描述
in			如果在指定的序列中找到值返回True，否则返回False
not in		如果在指定的序列中没有找到值返回True，否则返回False

Python身份运算符
身份运算符用于比较两个对象的存储单元
运算符		描述
is			is是判断两个标识符是不是引用自一个对象：x is y, 类似id(x) == id(y), 如果引用的是同一个对象则返回True，否则返回False
is not		is not是判断两个标识符是不是引用自不同对象：x is not y ， 类似id(x) != id(y)。如果引用的不是同一个对象则返回结果True，否则返回False。
注： id()函数用于获取对象内存地址。
is与==区别：
is用于判断两个变量引用对象是否为同一个，==用于判断引用变量的值是否相等。

Python运算符优先级
以下表格列出了从最高到最低优先级的所有运算符，相同单元格内的运算符具有相同优先级。运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）：
运算符														描述
(expressions...),
[expressions...], {key: value...}, {expressions...}			圆括号的表达式
x[index], x[index:index], x(arguments...), x.attribute		读取，切片，调用，属性引用
await x														await 表达式
**															乘方(指数)
+x, -x, ~x													正，负，按位非 NOT
*, @, /, //, %												乘，矩阵乘，除，整除，取余
+, -														加和减
<<, >>														移位
&															按位与 AND
^															按位异或 XOR
|															按位或 OR
in,not in, is,is not, <, <=, >, >=, !=, ==					比较运算，包括成员检测和标识号检测
not x														逻辑非 NOT
and															逻辑与 AND
or															逻辑或 OR
if -- else													条件表达式
lambda														lambda 表达式
:=															赋值表达式
注意：Python3 已不支持 <> 运算符，可以使用!=代替，如果你一定要使用这种比较运算符，可以使用以下的方式：
>>> from __future__ import barry_as_FLUFL
>>> 1 <> 2
True

Python字符串格式化
Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符%s的字符串中。
在 Python 中，字符串格式化使用与C中sprintf函数一样的语法。
#!/usr/bin/python3
print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
以上实例输出结果：
我叫 小明 今年 10 岁!
python字符串格式化符号:
符号			描述
%c				格式化字符及其ASCII码
%s				格式化字符串
%d				格式化整数
%u				格式化无符号整型
%o				格式化无符号八进制数
%x				格式化无符号十六进制数
%X				格式化无符号十六进制数（大写）
%f				格式化浮点数字，可指定小数点后的精度
%e				用科学计数法格式化浮点数
%E				作用同%e，用科学计数法格式化浮点数
%g				%f和%e的简写
%G				%f 和 %E 的简写
%p				用十六进制数格式化变量的地址
格式化操作符辅助指令:
符号			功能
*				定义宽度或者小数点精度
-				用做左对齐
+				在正数前面显示加号( + )
<sp>			在正数前面显示空格
#				在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')
0				显示的数字前面填充'0'而不是默认的空格
%				'%%'输出一个单一的'%'
(var)			映射变量(字典参数)
m.n.			m是显示的最小总宽度, n是小数点后的位数(如果可用的话)
Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。

Python三引号
python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。
#!/usr/bin/python3
para_str = """这是一个多行字符串的实例
多行字符串可以使用制表符
TAB ( \t )。
也可以使用换行符 [ \n ]。
"""
print(para_str)
以上实例执行结果为：
这是一个多行字符串的实例
多行字符串可以使用制表符
TAB (    )。
也可以使用换行符 [ 
 ]。

f-string
f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。
之前我们习惯用百分号(%):
>>> name = 'Runoob'
>>> 'Hello %s' % name
'Hello Runoob'
f-string 格式化字符串以f开头，后面跟着字符串，字符串中的表达式用大括号{}包起来，它会将变量或表达式计算后的值替换进去，实例如下：
>>> name = 'Runoob'
>>> f'Hello {name}'  # 替换变量
'Hello Runoob'
>>> f'{1+2}'         # 使用表达式
'3'
>>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}
>>> f'{w["name"]}: {w["url"]}'
'Runoob: www.runoob.com'
用了这种方式明显更简单了，不用再去判断使用%s，还是%d。
在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果：
>>> x = 1
>>> print(f'{x+1}')   # Python 3.6
2
>>> x = 1
>>> print(f'{x+1=}')   # Python 3.8
x+1=2

Unicode 字符串
在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。
使用的语法是在字符串前面加上前缀u。
在Python3中，所有的字符串都是Unicode字符串。

Python 的字符串内建函数
Python 的字符串常用内建函数如下：
1、capitalize()
将字符串的第一个字符转换为大写
2、center(width, fillchar)
返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。
3、count(str, beg= 0,end=len(string))
返回str在string里面出现的次数，如果beg或者end指定则返回指定范围内str出现的次数
4、bytes.decode(encoding="utf-8", errors="strict")
Python3中没有decode方法，但我们可以使用bytes对象的decode()方法来解码给定的bytes对象，这个bytes对象可以由str.encode()来编码返回。
5、encode(encoding='UTF-8',errors='strict')
以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'
6、endswith(suffix, beg=0, end=len(string))
检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。
7、expandtabs(tabsize=8)
把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。
8、find(str, beg=0, end=len(string)
检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1
9、index(str, beg=0, end=len(string))
跟find()方法一样，只不过如果str不在字符串中会报一个异常。
10、isalnum()
如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False
11、isalpha()
如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False
12、isdigit()
如果字符串只包含数字则返回 True 否则返回 False..
13、islower()
如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False
14、isnumeric()
如果字符串中只包含数字字符，则返回 True，否则返回 False
15、isspace()
如果字符串中只包含空白，则返回 True，否则返回 False.
16、istitle()
如果字符串是标题化的(见 title())则返回 True，否则返回 False
17、isupper()
如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False
18、join(seq)
以指定字符串作为分隔符，将se中所有的元素(的字符串表示)合并为一个新的字符串
19、len(string)
返回字符串长度
20、ljust(width[, fillchar])
返回一个原字符串左对齐,并使用fillchar填充至长度width的新字符串，fillchar默认为空格。
21、lower()
转换字符串中所有大写字符为小写.
22、lstrip()
截掉字符串左边的空格或指定字符。
23、maketrans()
创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
24、max(str)
返回字符串 str 中最大的字母。
25、min(str)
返回字符串 str 中最小的字母。
26、replace(old, new [, max])
把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。
27、rfind(str, beg=0,end=len(string))
类似于 find()函数，不过是从右边开始查找.
28、rindex( str, beg=0, end=len(string))
类似于 index()，不过是从右边开始.
29、rjust(width,[, fillchar])
返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串
30、rstrip()
删除字符串末尾的空格或指定字符。
31、split(str="", num=string.count(str))
以str为分隔符截取字符串，如果num有指定值，则仅截取num+1个子字符串
32、splitlines([keepends])
按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。
33、startswith(substr, beg=0,end=len(string))
检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。
34、strip([chars])
在字符串上执行 lstrip()和 rstrip()
35、swapcase()
将字符串中大写转换为小写，小写转换为大写
36、title()
返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())
37、translate(table, deletechars="")
根据table给出的表(包含 256 个字符)转换string的字符, 要过滤掉的字符放到deletechars参数中
38、upper()
转换字符串中的小写字母为大写
39、zfill (width)
返回长度为 width 的字符串，原字符串右对齐，前面填充0
40、isdecimal()
检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。

列表比较
列表比较需要引入operator模块的eq方法（详见：Python operator 模块）：
# 导入 operator 模块
import operator
a = [1, 2]
b = [2, 3]
c = [2, 3]
print("operator.eq(a,b): ", operator.eq(a,b))
print("operator.eq(c,b): ", operator.eq(c,b))
以上代码输出结果为：
operator.eq(a,b):  False
operator.eq(c,b):  True

Python列表函数&方法
Python包含以下函数:
1、len(list)
列表元素个数
2、max(list)
返回列表元素最大值
3、min(list)
返回列表元素最小值
4、list(seq)
将元组转换为列表
Python包含以下方法:
1、list.append(obj)
在列表末尾添加新的对象
2、list.count(obj)
统计某个元素在列表中出现的次数
3、list.extend(seq)
在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
4、list.index(obj)
从列表中找出某个值第一个匹配项的索引位置
5、list.insert(index, obj)
将对象插入列表
6、list.pop([index=-1])
移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
7、list.remove(obj)
移除列表中某个值的第一个匹配项
8、list.reverse()
反向列表中元素
9、list.sort(key=None, reverse=False)
对原列表进行排序
10、list.clear()
清空列表
11、list.copy()
复制列表

元组内置函数
Python元组包含了以下内置函数
1、len(tuple)
计算元组元素个数。
>>> tuple1 = ('Google', 'Runoob', 'Taobao')
>>> len(tuple1)
3
2、max(tuple)
返回元组中元素最大值。
>>> tuple2 = ('5', '4', '8')
>>> max(tuple2)
'8'
3、min(tuple)
返回元组中元素最小值。
>>> tuple2 = ('5', '4', '8')
>>> min(tuple2)
'4'
4、tuple(iterable)
将可迭代系列转换为元组。
>>> list1= ['Google', 'Taobao', 'Runoob', 'Baidu']
>>> tuple1=tuple(list1)
>>> tuple1
('Google', 'Taobao', 'Runoob', 'Baidu')
关于元组是不可变的
所谓元组的不可变指的是元组所指向的内存中的内容不可变。
>>> tup = ('r', 'u', 'n', 'o', 'o', 'b')
>>> tup[0] = 'g'     # 不支持修改元素
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> id(tup)     # 查看内存地址
4440687904
>>> tup = (1,2,3)
>>> id(tup)
4441088800    # 内存地址不一样了
从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。

字典内置函数&方法
Python字典包含了以下内置函数：
1、len(dict)
计算字典元素个数，即键的总数。
>>> tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> len(tinydict)
3
2、str(dict)
输出字典，可以打印的字符串表示。
>>> tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> str(tinydict)
"{'Name': 'Runoob', 'Class': 'First', 'Age': 7}"
3、type(variable)
返回输入的变量类型，如果变量是字典就返回字典类型。
>>> tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}
>>> type(tinydict)
<class 'dict'>
Python字典包含了以下内置方法：
1、dict.clear()
删除字典内所有元素
2、dict.copy()
返回一个字典的浅复制
3、dict.fromkeys()
创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
4、dict.get(key, default=None)
返回指定键的值，如果键不在字典中返回 default 设置的默认值
5、key in dict
如果键在字典dict里返回true，否则返回false
6、dict.items()
以列表返回一个视图对象
7、dict.keys()
返回一个视图对象
8、dict.setdefault(key, default=None)
和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
9、dict.update(dict2)
把字典dict2的键/值对更新到dict里
10、dict.values()
返回一个视图对象
11、pop(key[,default])
删除字典 key（键）所对应的值，返回被删除的值。
12、popitem()
返回并删除字典中的最后一对键和值。

集合内置方法完整列表
方法							描述
add()							为集合添加元素
clear()							移除集合中的所有元素
copy()							拷贝一个集合
difference()					返回多个集合的差集
difference_update()				移除集合中的元素，该元素在指定的集合也存在。
discard()						删除集合中指定的元素
intersection()					返回集合的交集
intersection_update()			返回集合的交集。
isdisjoint()					判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。
issubset()						判断指定集合是否为该方法参数集合的子集。
issuperset()					判断该方法的参数集合是否为指定集合的子集
pop()							随机移除元素
remove()						移除指定元素
symmetric_difference()			返回两个集合中不重复的元素集合。
symmetric_difference_update()	移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。
union()							返回两个集合的并集
update()						给集合添加元素
len()							计算集合元素个数

match...case
Python 3.10增加了 match...case 的条件判断，不需要再使用一连串的 if-else 来判断了。
match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，_ 可以匹配一切。
语法格式如下：
match subject:
    case <pattern_1>:
        <action_1>
    case <pattern_2>:
        <action_2>
    case <pattern_3>:
        <action_3>
    case _:
        <action_wildcard>
case _: 类似于 C 和 Java 中的 default:，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。

while循环使用else语句
如果while后面的条件语句为false时，则执行else的语句块。
语法格式如下：
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
expr条件语句为true则执行statement(s)语句块，如果为false，则执行additional_statement(s)。
循环输出数字，并判断大小：
#!/usr/bin/python3
count = 0
while count < 5:
   print (count, " 小于 5")
   count = count + 1
else:
   print (count, " 大于或等于 5")

for 语句
Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。
for循环的一般格式如下：
for <variable> in <sequence>:
    <statements>
else:
    <statements>

break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。
continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。
pass 语句
Python pass是空语句，是为了保持程序结构的完整性。
pass 不做任何事情，一般用做占位语句，如下实例
>>>while True:
...     pass  # 等待键盘中断 (Ctrl+C)

end关键字
关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：
#!/usr/bin/python3
# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b < 1000:
    print(b, end=',')
    a, b = b, a+b
执行以上程序，输出结果为：
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,

Python推导式
Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。
Python 支持各种数据结构的推导式：
列表(list)推导式
字典(dict)推导式
集合(set)推导式
元组(tuple)推导式
列表推导式格式为：
[表达式 for 变量 in 列表] 
[out_exp_res for out_exp in input_list]
或者 
[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
out_exp_res：列表生成元素表达式，可以是有返回值的函数。
for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。
if condition：条件语句，可以过滤列表中不符合条件的值。
过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：
>>> names = ['Bob','Tom','alice','Jerry','Wendy','Smith']
>>> new_names = [name.upper()for name in names if len(name)>3]
>>> print(new_names)
['ALICE', 'JERRY', 'WENDY', 'SMITH']
计算 30 以内可以被 3 整除的整数：
>>> multiples = [i for i in range(30) if i % 3 == 0]
>>> print(multiples)
[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]

字典推导式
字典推导基本格式：
{ key_expr: value_expr for value in collection }
或
{ key_expr: value_expr for value in collection if condition }
使用字符串及其长度创建字典：
listdemo = ['Google','Runoob', 'Taobao']
# 将列表中各字符串值为键，各字符串的长度为值，组成键值对
>>> newdict = {key:len(key) for key in listdemo}
>>> newdict
{'Google': 6, 'Runoob': 6, 'Taobao': 6}
提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：
>>> dic = {x: x**2 for x in (2, 4, 6)}
>>> dic
{2: 4, 4: 16, 6: 36}
>>> type(dic)
<class 'dict'>

集合推导式
集合推导式基本格式：
{ expression for item in Sequence }
或
{ expression for item in Sequence if conditional }
计算数字 1,2,3 的平方数：
>>> setnew = {i**2 for i in (1,2,3)}
>>> setnew
{1, 4, 9}
判断不是 abc 的字母并输出：
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'d', 'r'}
>>> type(a)
<class 'set'>

元组推导式（生成器表达式）
元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。
元组推导式基本格式：
(expression for item in Sequence )
或
(expression for item in Sequence if conditional )
元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象。
例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：
>>> a = (x for x in range(1,10))
>>> a
<generator object <genexpr> at 0x7faf6ee20a50>  # 返回的是生成器对象
>>> tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组
(1, 2, 3, 4, 5, 6, 7, 8, 9)

Python3迭代器与生成器
迭代器
迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。
迭代器是一个可以记住遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器有两个基本的方法：iter() 和 next()。
字符串，列表或元组对象都可用于创建迭代器：
实例(Python 3.0+)
>>> list=[1,2,3,4]
>>> it = iter(list)    # 创建迭代器对象
>>> print(next(it))   # 输出迭代器的下一个元素
1
>>> print(next(it))
2
>>>
迭代器对象可以使用常规for语句进行遍历：
#!/usr/bin/python3
list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print(x, end=" ")
执行以上程序，输出结果如下：
1 2 3 4
也可以使用 next() 函数：
#!/usr/bin/python3
import sys         # 引入 sys 模块

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
 
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
执行以上程序，输出结果如下：
1
2
3
4
创建一个迭代器
把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。
如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为__init__(), 它会在对象初始化的时候执行。
更多内容查阅：Python3 面向对象
__iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。
__next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
执行输出结果为：
1
2
3
4
5
StopIteration
StopIteration异常用于标识迭代的完成，防止出现无限循环的情况，在__next__()方法中我们可以设置在完成指定循环次数后触发StopIteration异常来结束迭代。
在 20 次迭代后停止执行：
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)
执行输出结果为：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
生成器
在 Python 中，使用了yield的函数被称为生成器（generator）。
yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。
跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
当在生成器函数中使用yield语句时，函数的执行将会暂停，并将yield后面的表达式作为当前迭代的值返回。
然后，每次调用生成器的next()方法或使用for循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。
调用一个生成器函数，返回的是一个迭代器对象。
下面是一个简单的示例，展示了生成器函数的使用：
def countdown(n):
    while n > 0:
        yield n
        n -= 1
 
# 创建生成器对象
generator = countdown(5)
 
# 通过迭代生成器获取值
print(next(generator))  # 输出: 5
print(next(generator))  # 输出: 4
print(next(generator))  # 输出: 3
 
# 使用 for 循环迭代生成器
for value in generator:
    print(value)  # 输出: 2 1
以上实例中，countdown函数是一个生成器函数。它使用yield语句逐步产生从 n 到 1 的倒数数字。在每次调用yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。
通过创建生成器对象并使用next()函数或for循环迭代生成器，我们可以逐步获取生成器函数产生的值。
在这个例子中，我们首先使用next()函数获取前三个倒数值，然后通过for循环获取剩下的两个倒数值。
生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。
此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。
执行以上程序，输出结果如下：
5
4
3
2
1
以下实例使用 yield 实现斐波那契数列：
#!/usr/bin/python3
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
执行以上程序，输出结果如下：
0 1 1 2 3 5 8 13 21 34 55

Python3函数
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。
函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。
定义一个函数
你可以定义一个由自己想要功能的函数，以下是简单的规则：
函数代码块以def关键词开头，后接函数标识符名称和圆括号()。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。
函数内容以冒号 : 起始，并且缩进。
return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的return相当于返回None。
Python定义函数使用def关键字，一般格式如下：
def 函数名（参数列表）:
    函数体
默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。
参数传递
在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：
a=[1,2,3]
a="Runoob"
以上代码中，[1,2,3] 是List类型，"Runoob"是String类型，而变量a是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向List类型对象，也可以是指向String类型对象。
可更改(mutable)与不可更改(immutable)对象
在 python 中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。
不可变类型：变量赋值a=5后再赋值a=10，这里实际是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变a的值，相当于新生成了a。
可变类型：变量赋值la=[1,2,3,4]后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
python 函数的参数传递：
不可变类型：类似C++的值传递，如整数、字符串、元组。如 fun(a)，传递的只是a的值，没有影响a对象本身。如果在fun(a)内部修改a的值，则是新生成一个a的对象。
可变类型：类似C++的引用传递，如列表，字典。如fun(la)，则是将la真正的传过去，修改后fun外部的la也会受影响
python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。
python传不可变对象实例
通过id()函数来查看内存地址变化：
def change(a):
    print(id(a))   # 指向的是同一个对象
    a=10
    print(id(a))   # 一个新对象

a=1
print(id(a))
change(a)
以上实例输出结果为：
4379369136
4379369136
4379369424
可以看见在调用函数前后，形参和实参指向的是同一个对象（对象id相同），在函数内部修改形参后，形参指向的是不同的id。
传可变对象实例
可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：
#!/usr/bin/python3
 
# 可写函数说明
def changeme(mylist):
   "修改传入的列表"
   mylist.append([1,2,3,4])
   print("函数内取值: ", mylist)
   return
 
# 调用changeme函数
mylist = [10,20,30]
changeme(mylist)
print("函数外取值: ", mylist)
传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：
函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
参数
以下是调用函数时可使用的正式参数类型：
必需参数
关键字参数
默认参数
不定长参数
必需参数
必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。
调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：
实例(Python 3.0+)
#!/usr/bin/python3
 
#可写函数说明
def printme(str):
   "打印任何传入的字符串"
   print(str)
   return
 
# 调用printme函数，不加参数会报错
printme()
以上实例输出结果：
Traceback (most recent call last):
  File "test.py", line 10, in <module>
    printme()
TypeError: printme() missing 1 required positional argument: 'str'
关键字参数
关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。
使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为Python解释器能够用参数名匹配参数值。
以下实例在函数printme()调用时使用参数名：
#!/usr/bin/python3
 
#可写函数说明
def printme(str):
   "打印任何传入的字符串"
   print(str)
   return
 
#调用printme函数
printme(str = "菜鸟教程")
以上实例输出结果：
菜鸟教程
以下实例中演示了函数参数的使用不需要使用指定顺序：
#!/usr/bin/python3
 
#可写函数说明
def printinfo(name, age):
   "打印任何传入的字符串"
   print("名字: ", name)
   print("年龄: ", age)
   return
 
#调用printinfo函数
printinfo(age=50, name="runoob")
以上实例输出结果：
名字:  runoob
年龄:  50
默认参数
调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入age参数，则使用默认值：
#!/usr/bin/python3
 
#可写函数说明
def printinfo(name, age = 35):
   "打印任何传入的字符串"
   print("名字: ", name)
   print("年龄: ", age)
   return
 
#调用printinfo函数
printinfo(age=50, name="runoob")
print ("------------------------")
printinfo(name="runoob")
以上实例输出结果：
名字:  runoob
年龄:  50
------------------------
名字:  runoob
年龄:  35
不定长参数
你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：
def functionname([formal_args,] *var_args_tuple):
   "函数_文档字符串"
   function_suite
   return [expression]
加了星号*的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。
#!/usr/bin/python3
  
# 可写函数说明
def printinfo(arg1, *vartuple):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vartuple)
 
# 调用printinfo函数
printinfo(70, 60, 50)
以上实例输出结果：
输出: 
70
(60, 50)
如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：
#!/usr/bin/python3
 
# 可写函数说明
def printinfo(arg1, *vartuple):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   for var in vartuple:
      print (var)
   return
 
# 调用printinfo函数
printinfo(10)
printinfo(70, 60, 50)
以上实例输出结果：
输出:
10
输出:
70
60
50
还有一种就是参数带两个星号**基本语法如下：
def functionname([formal_args,] **var_args_dict ):
   "函数_文档字符串"
   function_suite
   return [expression]
加了两个星号**的参数会以字典的形式导入。
#!/usr/bin/python3
  
# 可写函数说明
def printinfo(arg1, **vardict):
   "打印任何传入的参数"
   print ("输出: ")
   print (arg1)
   print (vardict)
 
# 调用printinfo 函数
printinfo(1, a=2,b=3)
以上实例输出结果：
输出: 
1
{'a': 2, 'b': 3}
声明函数时，参数中星号*可以单独出现，例如:
def f(a,b,*,c):
    return a+b+c
如果单独出现星号*，则星号*后的参数必须用关键字传入：

>>> def f(a,b,*,c):
...     return a+b+c
... 
>>> f(1,2,3)   # 报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 2 positional arguments but 3 were given
>>> f(1,2,c=3) # 正常
6
>>>
匿名函数
Python 使用lambda来创建匿名函数。
所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。
lambda 只是一个表达式，函数体比def简单很多。
lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，内联函数的目的是调用小函数时不占用栈内存从而减少函数调用的开销，提高代码的执行速度。
语法
lambda 函数的语法只包含一个语句，如下：
lambda [arg1 [,arg2,.....argn]]:expression
设置参数a加上10:
x = lambda a : a + 10
print(x(5))
以上实例输出结果：
15
以下实例匿名函数设置两个参数：
#!/usr/bin/python3
 
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
 
# 调用sum函数
print("相加后的值为: ", sum(10, 20))
print("相加后的值为: ", sum(20, 20))
以上实例输出结果：
相加后的值为:  30
相加后的值为:  40
我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。
以下实例将匿名函数封装在myfunc函数中，通过传入不同的参数来创建不同的匿名函数：
实例
def myfunc(n):
  return lambda a : a * n
 
mydoubler = myfunc(2)
mytripler = myfunc(3)
 
print(mydoubler(11))
print(mytripler(11))
以上实例输出结果：
22
33
更多匿名函数还可以参考：Python lambda（匿名函数）
return 语句
return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了return语句的用法：
#!/usr/bin/python3
 
# 可写函数说明
def sum(arg1, arg2):
   # 返回2个参数的和."
   total = arg1 + arg2
   print("函数内 : ", total)
   return total
 
# 调用sum函数
total = sum(10, 20)
print ("函数外: ", total)
以上实例输出结果：
函数内 :  30
函数外 :  30
强制位置参数
Python3.8 新增了一个函数形参语法/用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。
在以下的例子中，形参a和b必须使用指定位置参数，c或d可以是位置形参或关键字形参，而e和f要求为关键字形参:
def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
以下使用方法是正确的:
f(10, 20, 30, d=40, e=50, f=60)
以下使用方法会发生错误:
f(10, b=20, c=30, d=40, e=50, f=60)   # b不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e必须使用关键字参数的形式


Python模块
Python模块(Module)，是一个 Python文件，以.py结尾，包含了Python对象定义和Python语句。
模块让你能够有逻辑地组织你的Python代码段。
把相关的代码分配到一个模块里能让你的代码更好用，更易懂。
模块能定义函数，类和变量，模块里也能包含可执行的代码。
下例是个简单的模块 support.py：
support.py 模块：
def print_func(par):
   print "Hello : ", par
   return

import 语句
模块的引入
模块定义好后，我们可以使用import语句来引入模块，语法如下：
import module1[, module2[,... moduleN]]
比如要引用模块 math，就可以在文件最开始的地方用import math来引入。在调用math模块中的函数时，必须这样引用：
模块名.函数名
当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。
搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端：
test.py 文件代码：
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 导入模块
import support
 
# 现在可以调用模块里包含的函数了
support.print_func("Runoob")
以上实例输出结果：
Hello : Runoob
一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。

from…import 语句
Python的from语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：
from modname import name1[, name2[, ... nameN]]
例如，要导入模块fib的fibonacci函数，使用如下语句：
from fib import fibonacci
这个声明不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入到执行这个声明的模块的全局符号表。

from…import *语句
把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：
from modname import *
这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。
例如我们想一次性引入math模块中所有的东西，语句如下：
from math import *

搜索路径
当你导入一个模块，Python解析器对模块位置的搜索顺序是：
1、当前目录
2、如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。
3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。
模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。


PYTHONPATH变量
作为环境变量，PYTHONPATH由装在一个列表里的许多目录组成。PYTHONPATH的语法和shell变量PATH的一样。
在 Windows系统，典型的PYTHONPATH如下：
set PYTHONPATH=c:\python27\lib;
在 UNIX 系统，典型的PYTHONPATH如下：
set PYTHONPATH=/usr/local/lib/python

命名空间和作用域
变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。
一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。
每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。
Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。
因此，如果要给函数内的全局变量赋值，必须使用global语句。
global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。
例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量Money赋值，然后Python会假定Money是一个局部变量。然而，我们并没有在访问前声明一个局部变量Money，结果就是会出现一个UnboundLocalError 的错误。取消 global语句前的注释符就能解决这个问题。
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
Money = 2000
def AddMoney():
   # 想改正代码就取消以下注释:
   # global Money
   Money = Money + 1
 
print Money
AddMoney()
print Money

dir()函数
dir()函数一个排好序的字符串列表，内容是一个模块里定义过的名字。
返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：

#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 导入内置math模块
import math
 
content = dir(math)
print content;
以上实例输出结果：
['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan', 
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp', 
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 
'sqrt', 'tan', 'tanh']
在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。


globals()和locals()函数
根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
如果在函数内部调用locals()，返回的是所有能在该函数里访问的命名。
如果在函数内部调用globals()，返回的是所有在该函数里能访问的全局名字。
两个函数的返回类型都是字典。所以名字们能用 keys()函数摘取。


reload()函数
当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。
因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数。该函数会重新导入之前导入过的模块。语法如下：
reload(module_name)
在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载hello模块，如下：
reload(hello)

Python中的包
包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的Python的应用环境。
简单来说，包就是文件夹，但该文件夹下必须存在__init__.py文件, 该文件的内容可以为空。__init__.py用于标识当前文件夹是一个包。
考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、__init__.py 文件，test.py为测试调用包的代码，目录结构如下：
test.py
package_runoob
|-- __init__.py
|-- runoob1.py
|-- runoob2.py源代码如下：
package_runoob/runoob1.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
def runoob1():
   print "I'm in runoob1"
package_runoob/runoob2.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
def runoob2():
   print "I'm in runoob2"
现在，在 package_runoob 目录下创建__init__.py：
package_runoob/__init__.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
if __name__ == '__main__':
    print '作为主程序运行'
else:
    print 'package_runoob 初始化'
然后我们在package_runoob同级目录下创建test.py来调用package_runoob包
test.py
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 导入 Phone 包
from package_runoob.runoob1 import runoob1
from package_runoob.runoob2 import runoob2
 
runoob1()
runoob2()
以上实例输出结果：
package_runoob 初始化
I'm in runoob1
I'm in runoob2
如上，为了举例，我们只在每个文件里放置了一个函数，但其实你可以放置许多函数。你也可以在这些文件里定义Python的类，然后为这些类建一个包。


打开和关闭文件
Python提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用file对象做大部分的文件操作。

open函数
你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。
语法：
file object = open(file_name [, access_mode][, buffering])
各个参数的细节如下：
file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。
access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。
不同模式打开文件的完全列表：
模式	描述
t	文本模式 (默认)。
x	写模式，新建一个文件，如果该文件已存在则会报错。
b	二进制模式。
+	打开一个文件进行更新(可读可写)。
U	通用换行模式（不推荐）。
r	以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
rb	以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。
r+	打开一个文件用于读写。文件指针将会放在文件的开头。
rb+	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。
w	打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
wb	以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
w+	打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
a	打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
ab	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
ab+	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
默认为文本模式，如果要以二进制模式打开，加上b。

File对象的属性
一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。
以下是和file对象相关的所有属性的列表：
属性                                         描述
file.closed         返回true如果文件已被关闭，否则返回false。
file.mode           返回被打开文件的访问模式。
file.name           返回文件的名称。
file.softspace      如果用print输出后，必须跟一个空格符，则返回false。否则返回true。
如下实例：
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "w")
print "文件名: ", fo.name
print "是否已关闭 : ", fo.closed
print "访问模式 : ", fo.mode
print "末尾是否强制加空格 : ", fo.softspace
以上实例输出结果：
文件名:  foo.txt
是否已关闭 :  False
访问模式 :  w
末尾是否强制加空格 :  0

close()方法
File对象的close()方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。
当一个文件对象的引用被重新指定给另一个文件时，Python会关闭之前的文件。用 close()方法关闭文件是一个很好的习惯。
语法：
fileObject.close()
例子：
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "w")
print "文件名: ", fo.name
 
# 关闭打开的文件
fo.close()
以上实例输出结果：
文件名:  foo.txt

读写文件：
file对象提供了一系列方法，能让我们的文件访问更轻松。来看看如何使用read()和write()方法来读取和写入文件。
write()方法
write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。
write()方法不会在字符串的结尾添加换行符('\n')：
语法：
fileObject.write(string)
在这里，被传递的参数是要写入到已打开文件的内容。
例子：
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "w")
fo.write("www.runoob.com!\nVery good site!\n")
 
# 关闭打开的文件
fo.close()
上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:
$ cat foo.txt 
www.runoob.com!
Very good site!

read()方法
read()方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。
语法：
fileObject.read([count])
在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。
例子：
这里我们用到以上创建的 foo.txt 文件。
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "r+")
str = fo.read(10)
print("读取的字符串是 : ", str)
# 关闭打开的文件
fo.close()
以上实例输出结果：
读取的字符串是 :  www.runoob

文件定位
tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。
seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。
如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。
例子：
就用我们上面创建的文件foo.txt。
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "r+")
str = fo.read(10)
print("读取的字符串是 : ", str)
 
# 查找当前位置
position = fo.tell()
print("当前文件位置 : ", position)
 
# 把指针再次重新定位到文件开头
position = fo.seek(0, 0)
str = fo.read(10)
print("重新读取字符串 : ", str)
# 关闭打开的文件
fo.close()
以上实例输出结果：
读取的字符串是 :  www.runoob
当前文件位置 :  10
重新读取字符串 :  www.runoob

重命名和删除文件
Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。
要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。
rename() 方法
rename() 方法需要两个参数，当前的文件名和新文件名。
语法：
os.rename(current_file_name, new_file_name)
例子：
下例将重命名一个已经存在的文件test1.txt。
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 重命名文件test1.txt到test2.txt。
os.rename("test1.txt", "test2.txt")

remove()方法
你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。
语法：
os.remove(file_name)
例子：
下例将删除一个已经存在的文件test2.txt。
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 删除一个已经存在的文件test2.txt
os.remove("test2.txt")

Python里的目录：
所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。
mkdir()方法
可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。
语法：
os.mkdir("newdir")
例子：
下例将在当前目录下创建一个新目录test。
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 创建目录test
os.mkdir("test")

chdir()方法
可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。
语法：
os.chdir("newdir")
例子：
下例将进入"/home/newdir"目录。
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 将当前目录改为"/home/newdir"
os.chdir("/home/newdir")

getcwd() 方法
getcwd()方法显示当前的工作目录。
语法：
os.getcwd()
例子：
下例给出当前目录：
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 给出当前的目录
print(os.getcwd())

rmdir()方法
rmdir()方法删除目录，目录名称以参数传递。
在删除这个目录之前，它的所有内容应该先被清除。
语法：
os.rmdir('dirname')
例子：
以下是删除" /tmp/test"目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。
#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 删除”/tmp/test”目录
os.rmdir( "/tmp/test"  )

file 对象
file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：
1、file.close()
关闭文件。关闭后文件不能再进行读写操作。
2、file.flush()
刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。
3、file.fileno()
返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。
4、file.isatty()
如果文件连接到一个终端设备返回 True，否则返回 False。
5、file.next()
返回文件下一行。
6、file.read([size])
从文件读取指定的字节数，如果未给定或为负则读取所有。
7、file.readline([size])
读取整行，包括 "\n" 字符。
8、file.readlines([sizeint])
读取所有行并返回列表，若给定sizeint>0，则是设置一次读多少字节，这是为了减轻读取压力。
9、file.seek(offset[, whence])
设置文件当前位置
10、file.tell()
返回文件当前位置。
11、file.truncate([size])
截取文件，截取的字节通过size指定，默认为当前文件位置。
12、file.write(str)
将字符串写入文件，返回的是写入的字符长度。
13、file.writelines(sequence)
向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。

Python OS文件/目录方法
os模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：
1、os.access(path, mode)
检验权限模式
2、os.chdir(path)
改变当前工作目录
3、os.chflags(path, flags)
设置路径的标记为数字标记。
4、os.chmod(path, mode)
更改权限
5、os.chown(path, uid, gid)
更改文件所有者
6、os.chroot(path)
改变当前进程的根目录
7、os.close(fd)
关闭文件描述符 fd
8、os.closerange(fd_low, fd_high)
关闭所有文件描述符，从fd_low(包含)到fd_high(不包含), 错误会忽略
9、os.dup(fd)
复制文件描述符 fd
10、os.dup2(fd, fd2)
将一个文件描述符 fd 复制到另一个 fd2
11、os.fchdir(fd)
通过文件描述符改变当前工作目录
12、os.fchmod(fd, mode)
改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。
13、os.fchown(fd, uid, gid)
修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。
14、os.fdatasync(fd)
强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。
15、os.fdopen(fd[, mode[, bufsize]])
通过文件描述符fd创建一个文件对象，并返回这个文件对象
16、os.fpathconf(fd, name)
返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。
17、os.fstat(fd)
返回文件描述符fd的状态，像stat()。
18、os.fstatvfs(fd)
返回包含文件描述符fd的文件的文件系统的信息，像statvfs()
19、os.fsync(fd)
强制将文件描述符为fd的文件写入硬盘。
20、os.ftruncate(fd, length)
裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。
21、os.getcwd()
返回当前工作目录
22、os.getcwdu()
返回一个当前工作目录的Unicode对象
23、os.isatty(fd)
如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。
24、os.lchflags(path, flags)
设置路径的标记为数字标记，类似 chflags()，但是没有软链接
25、os.lchmod(path, mode)
修改连接文件权限
26、os.lchown(path, uid, gid)
更改文件所有者，类似 chown，但是不追踪链接。
27、os.link(src, dst)
创建硬链接，名为参数 dst，指向参数 src
28、os.listdir(path)
返回path指定的文件夹包含的文件或文件夹的名字的列表。
29、os.lseek(fd, pos, how)
设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者0设置从文件开始的计算的pos; SEEK_CUR或者1则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效
30、os.lstat(path)
像stat(),但是没有软链接
31、os.major(device)
从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。
32、os.makedev(major, minor)
以major和minor设备号组成一个原始设备号
33、os.makedirs(path[, mode])
递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。
34、os.minor(device)
从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。
35、os.mkdir(path[, mode])
以数字mode的mode创建一个名为path的文件夹.默认的 mode是0777(八进制)。
36、os.mkfifo(path[, mode])
创建命名管道，mode 为数字，默认为 0666 (八进制)
37、os.mknod(filename[, mode=0600, device])
创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。
38、os.open(file, flags[, mode])
打开一个文件，并且设置需要的打开选项，mode参数是可选的
39、os.openpty()
打开一个新的伪终端对。返回 pty 和 tty的文件描述符。
40、os.pathconf(path, name)
返回相关文件的系统配置信息。
41、os.pipe()
创建一个管道. 返回一对文件描述符(r, w) 分别为读和写
42、os.popen(command[, mode[, bufsize]])
从一个 command 打开一个管道
43、os.read(fd, n)
从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。
44、os.readlink(path)
返回软链接所指向的文件
45、os.remove(path)
删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。
46、os.removedirs(path)
递归删除目录。
47、os.rename(src, dst)
重命名文件或目录，从 src 到 dst
48、os.renames(old, new)
递归地对目录进行更名，也可以对文件进行更名。
49、os.rmdir(path)
删除path指定的空目录，如果目录非空，则抛出一个OSError异常。
50、os.stat(path)
获取path指定的路径的信息，功能等同于C API中的stat()系统调用。
51、os.stat_float_times([newvalue])
决定stat_result是否以float对象显示时间戳
52、os.statvfs(path)
获取指定路径的文件系统统计信息
53、os.symlink(src, dst)
创建一个软链接
54、os.tcgetpgrp(fd)
返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组
55、os.tcsetpgrp(fd, pg)
设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。
56、os.tempnam([dir[, prefix]])
返回唯一的路径名用于创建临时文件。
57、os.tmpfile()
返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。
58、os.tmpnam()
为创建一个临时文件返回一个唯一的路径
59、os.ttyname(fd)
返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。
60、os.unlink(path)
删除文件
61、os.utime(path, times)
返回指定的path文件的访问和修改的时间。
62、os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
输出在文件夹中的文件名通过在树中游走，向上或者向下。
63、os.write(fd, str)
写入字符串到文件描述符fd中. 返回实际写入的字符串长度
64、os.path 模块
获取文件的属性信息。

Python 异常处理
python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。
python标准异常
异常名称                           描述
BaseException                 所有异常的基类
SystemExit                    解释器请求退出
KeyboardInterrupt             用户中断执行(通常是输入^C)
Exception                     常规错误的基类
StopIteration                 迭代器没有更多的值
GeneratorExit                 生成器(generator)发生异常来通知退出
StandardError                 所有的内建标准异常的基类
ArithmeticError               所有数值计算错误的基类
FloatingPointError            浮点计算错误
OverflowError                 数值运算超出最大限制
ZeroDivisionError             除(或取模)零 (所有数据类型)
AssertionError                断言语句失败
AttributeError                对象没有这个属性
EOFError                      没有内建输入,到达EOF 标记
EnvironmentError              操作系统错误的基类
IOError                       输入/输出操作失败
OSError                       操作系统错误
WindowsError                  系统调用失败
ImportError                   导入模块/对象失败
LookupError                   无效数据查询的基类
IndexError                    序列中没有此索引(index)
KeyError                      映射中没有这个键
MemoryError                   内存溢出错误(对于Python 解释器不是致命的)
NameError                     未声明/初始化对象 (没有属性)
UnboundLocalError             访问未初始化的本地变量
ReferenceError                弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError                  一般的运行时错误
NotImplementedError           尚未实现的方法
SyntaxError	Python            语法错误
IndentationError              缩进错误
TabError                      Tab 和空格混用
SystemError                   一般的解释器系统错误
TypeError                     对类型无效的操作
ValueError                    传入无效的参数
UnicodeError                  Unicode 相关的错误
UnicodeDecodeError            Unicode 解码时的错误
UnicodeEncodeError            Unicode 编码时错误
UnicodeTranslateError         Unicode 转换时错误
Warning                       警告的基类
DeprecationWarning            关于被弃用的特征的警告
FutureWarning                 关于构造将来语义会有改变的警告
OverflowWarning               旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning     关于特性将会被废弃的警告
RuntimeWarning                可疑的运行时行为(runtime behavior)的警告
SyntaxWarning                 可疑的语法的警告
UserWarning                   用户代码生成的警告

什么是异常？
异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。
一般情况下，在Python无法正常处理程序时就会发生一个异常。
异常是Python对象，表示一个错误。
当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。

异常处理
捕捉异常可以使用try/except语句。
try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。
如果你不想在异常发生时结束你的程序，只需在try里捕获它。
语法：
以下为简单的try....except...else的语法：
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。
如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。
如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。
如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。
实例
下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常：
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open("testfile", "w")
    fh.write("这是一个测试文件，用于测试异常!!")
except IOError:
    print("Error: 没有找到文件或读取文件失败")
else:
    print("内容写入文件成功")
    fh.close()
以上程序输出结果：
$ python test.py 
内容写入文件成功
$ cat testfile       # 查看写入的内容
这是一个测试文件，用于测试异常!!
实例
下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常：
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open("testfile", "w")
    fh.write("这是一个测试文件，用于测试异常!!")
except IOError:
    print "Error: 没有找到文件或读取文件失败"
else:
    print "内容写入文件成功"
    fh.close()
在执行代码前为了测试方便，我们可以先去掉 testfile文件的写权限，命令如下：
chmod -w testfile
再执行以上代码：
$ python test.py 
Error: 没有找到文件或读取文件失败

使用except而不带任何异常类型
你可以不带任何异常类型使用except，如下实例：
try:
    正常的操作
   ......................
except:
    发生异常，执行这块代码
   ......................
else:
    如果没有异常执行这块代码
以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。

使用except而带多种异常类型
你也可以使用相同的except语句来处理多个异常信息，如下所示：
try:
    正常的操作
   ......................
except(Exception1[, Exception2[,...ExceptionN]]):
   发生以上多个异常中的一个，执行这块代码
   ......................
else:
    如果没有异常执行这块代码
    
try-finally 语句
try-finally 语句无论是否发生异常都将执行最后的代码。
try:
<语句>
finally:
<语句>    #退出try时总会执行
raise
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open("testfile", "w")
    fh.write("这是一个测试文件，用于测试异常!!")
finally:
    print("Error: 没有找到文件或读取文件失败")
如果打开的文件没有可写权限，输出如下所示：
$ python test.py 
Error: 没有找到文件或读取文件失败
同样的例子也可以写成如下方式：
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open("testfile", "w")
    try:
        fh.write("这是一个测试文件，用于测试异常!!")
    finally:
        print("关闭文件")
        fh.close()
except IOError:
    print("Error: 没有找到文件或读取文件失败")
当在try块中抛出一个异常，立即执行finally块代码。
finally块中的所有语句执行后，异常被再次触发，并执行except块代码。
参数的内容不同于异常。

异常的参数
一个异常可以带上参数，可作为输出的异常信息参数。
你可以通过except语句来捕获异常的参数，如下所示：
try:
    正常的操作
   ......................
except ExceptionType, Argument:
    你可以在这输出 Argument 的值...
变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。
元组通常包含错误字符串，错误数字，错误位置。
以下为单个异常的实例：
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 定义函数
def temp_convert(var):
    try:
        return int(var)
    except ValueError, Argument:
        print "参数没有包含数字\n", Argument
# 调用函数
temp_convert("xyz")
以上程序执行结果如下：
$ python test.py 
参数没有包含数字
invalid literal for int() with base 10: 'xyz'

触发异常
我们可以使用raise语句自己触发异常
raise语法格式如下：
raise [Exception [, args [, traceback]]]
语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。
最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。
实例
一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。
定义一个异常非常简单，如下所示：
实例
def functionName( level ):
    if level < 1:
        raise Exception("Invalid level!", level)
        # 触发异常后，后面的代码就不会再执行
注意：为了能够捕获异常，"except"语句必须有用相同的异常来抛出类对象或者字符串。
例如我们捕获以上异常，"except"语句如下所示：
try:
    正常逻辑
except Exception,err:
    触发自定义异常    
else:
    其余代码
实例
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 定义函数
def mye( level ):
    if level < 1:
        raise Exception,"Invalid level!"
        # 触发异常后，后面的代码就不会再执行
try:
    mye(0)            # 触发异常
except Exception,err:
    print 1,err
else:
    print 2
执行以上代码，输出结果为：
$ python test.py 
1 Invalid level!

用户自定义异常
通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。
以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。
在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。
class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg
在你定义以上类后，你可以触发该异常，如下所示：
try:
    raise Networkerror("Bad hostname")
except Networkerror,e:
    print e.args

Python OS文件/目录方法
os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：
1、os.access(path, mode)
检验权限模式
2、os.chdir(path)
改变当前工作目录
3、os.chflags(path, flags)
设置路径的标记为数字标记。
4、os.chmod(path, mode)
更改权限
5、os.chown(path, uid, gid)
更改文件所有者
6、os.chroot(path)
改变当前进程的根目录
7、os.close(fd)
关闭文件描述符 fd
8、os.closerange(fd_low, fd_high)
关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略
9、os.dup(fd)
复制文件描述符 fd
10、os.dup2(fd, fd2)
将一个文件描述符 fd 复制到另一个 fd2
11、os.fchdir(fd)
通过文件描述符改变当前工作目录
12、os.fchmod(fd, mode)
改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。
13、os.fchown(fd, uid, gid)
修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。
14、os.fdatasync(fd)
强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。
15、os.fdopen(fd[, mode[, bufsize]])
通过文件描述符 fd 创建一个文件对象，并返回这个文件对象
16、os.fpathconf(fd, name)
返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。
17、os.fstat(fd)
返回文件描述符fd的状态，像stat()。
18、os.fstatvfs(fd)
返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()
19、os.fsync(fd)
强制将文件描述符为fd的文件写入硬盘。
20、os.ftruncate(fd, length)
裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。
21、os.getcwd()
返回当前工作目录
22、os.getcwdu()
返回一个当前工作目录的Unicode对象
23、os.isatty(fd)
如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。
24、os.lchflags(path, flags)
设置路径的标记为数字标记，类似 chflags()，但是没有软链接
25、os.lchmod(path, mode)
修改连接文件权限
26、os.lchown(path, uid, gid)
更改文件所有者，类似 chown，但是不追踪链接。
27、os.link(src, dst)
创建硬链接，名为参数 dst，指向参数 src
28、os.listdir(path)
返回path指定的文件夹包含的文件或文件夹的名字的列表。
29、os.lseek(fd, pos, how)
设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效
30、os.lstat(path)
像stat(),但是没有软链接
31、os.major(device)
从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。
32、os.makedev(major, minor)
以major和minor设备号组成一个原始设备号
33、os.makedirs(path[, mode])
递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。
34、os.minor(device)
从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。
35、os.mkdir(path[, mode])
以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。
36、os.mkfifo(path[, mode])
创建命名管道，mode 为数字，默认为 0666 (八进制)
37、os.mknod(filename[, mode=0600, device])
创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。
38、os.open(file, flags[, mode])
打开一个文件，并且设置需要的打开选项，mode参数是可选的
39、os.openpty()
打开一个新的伪终端对。返回 pty 和 tty的文件描述符。
40、os.pathconf(path, name)
返回相关文件的系统配置信息。
41、os.pipe()
创建一个管道. 返回一对文件描述符(r, w) 分别为读和写
42、os.popen(command[, mode[, bufsize]])
从一个 command 打开一个管道
43、os.read(fd, n)
从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。
44、os.readlink(path)
返回软链接所指向的文件
45、os.remove(path)
删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。
46、os.removedirs(path)
递归删除目录。
47、os.rename(src, dst)
重命名文件或目录，从 src 到 dst
48、os.renames(old, new)
递归地对目录进行更名，也可以对文件进行更名。
49、os.rmdir(path)
删除path指定的空目录，如果目录非空，则抛出一个OSError异常。
50、os.stat(path)
获取path指定的路径的信息，功能等同于C API中的stat()系统调用。
51、os.stat_float_times([newvalue])
决定stat_result是否以float对象显示时间戳
52、os.statvfs(path)
获取指定路径的文件系统统计信息
53、os.symlink(src, dst)
创建一个软链接
54、os.tcgetpgrp(fd)
返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组
55、os.tcsetpgrp(fd, pg)
设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。
56、os.tempnam([dir[, prefix]])
返回唯一的路径名用于创建临时文件。
57、os.tmpfile()
返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。
58、os.tmpnam()
为创建一个临时文件返回一个唯一的路径
59、os.ttyname(fd)
返回一个字符串，它表示与文件描述符fd关联的终端设备。如果fd没有与终端设备关联，则引发一个异常。
60、os.unlink(path)
删除文件
61、os.utime(path, times)
返回指定的path文件的访问和修改的时间。
62、os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
输出在文件夹中的文件名通过在树中游走，向上或者向下。
63、os.write(fd, str)
写入字符串到文件描述符fd中. 返回实际写入的字符串长度
64、os.path 模块
获取文件的属性信息。

Python 内置函数	
abs()	divmod()	input()	open()	staticmethod()
all()	enumerate()	int()	ord()	str()
any()	eval()	isinstance()	pow()	sum()
basestring()	execfile()	issubclass()	print()	super()
bin()	file()	iter()	property()	tuple()
bool()	filter()	len()	range()	type()
bytearray()	float()	list()	raw_input()	unichr()
callable()	format()	locals()	reduce()	unicode()
chr()	frozenset()	long()	reload()	vars()
classmethod()	getattr()	map()	repr()	xrange()
cmp()	globals()	max()	reverse()	zip()
compile()	hasattr()	memoryview()	round()	__import__()
complex()	hash()	min()	set()	
delattr()	help()	next()	setattr()	
dict()	hex()	object()	slice()	
dir()	id()	oct()	sorted()	exec 内置表达式

